checkresiduals(fit.ar11)
checkresiduals(fit1)
autocorr <- ARMAacf(ar=c(0.8, -0.4), ma=0.6, lag.max=20)  ###theoretical ACF
plot(0:20, autocorr, type="h", xlab="Lag", main="ACF of ARMA(2,1)")
autocorr <- ARMAacf(ar=c(0.8, -0.4), ma=0.6,  pacf=TRUE, lag.max=20)   ##Theoretical PACF
plot(1:20, autocorr, type="h", xlab="Lag",  main="ACF of ARMA(2,1)")
###Analysis of Beaver Data
library(forecast)
beaver <- beaver1$temp
tsdisplay(beaver, points = FALSE, main="Temperature of a Beaver")
fit0 <- arima(beaver, order=c(1,0,1))
fit0
###Ma is not siginificant
fit1 <- arima(beaver, order=c(1,0,0))
fit1
###Diagnostics
tsdisplay(residuals(fit1), points=FALSE, main="Residual plot")
checkresiduals(fit1)
checkresiduals(fit0)
library(astsa)
data("jj")
ts.plot(jj)
acf(jj)
autocorr <- ARMAacf(ar=c(0.8, -0.4), ma=0.6, lag.max=20)  ###theoretical ACF
plot(0:20, autocorr, type="h", xlab="Lag", main="ACF of ARMA(2,1)")
autocorr <- ARMAacf(ar=c(0.8, -0.4), ma=0.6,  pacf=TRUE, lag.max=20)   ##Theoretical PACF
plot(1:20, autocorr, type="h", xlab="Lag",  main="ACF of ARMA(2,1)")
###Analysis of Beaver Data
library(forecast)
help("beaver1")
beaver <- beaver1$temp
tsdisplay(beaver, points = FALSE, main="Temperature of a Beaver")
fit0 <- arima(beaver, order=c(1,0,1))
fit0
###Ma is not siginificant
fit1 <- arima(beaver, order=c(1,0,0))
###Ma is not siginificant
fit1 <- arima(beaver, order=c(1,0,0))
fit1
###Diagnostics
tsdisplay(residuals(fit1), points=FALSE, main="Residual plot")
checkresiduals(fit1)
###Use of model selection criteria
library(fpp)
l.sunspotarea <- log(sunspotarea)
tsdisplay(l.sunspotarea)
fit <- auto.arima(log(sunspotarea), max.p=10, max.q=10,
stationary=TRUE, seasonal=FALSE, ic="aic",
stepwise=FALSE)
fit
checkresiduals(fit)
library(TSA)
library(forecast)
data(oil.price)
log.price <- log(oil.price)
tsdisplay(log.price, points= FALSE)
####differncing
d.log.price <- diff(log.price)
tsdisplay(d.log.price, points = FALSE)
tsdisplay(d.log.price, points = FALSE)
###fit the data
fit <- arima(log.price, order=c(1,1,1))
fit
checkresiduals(fit)
######Non-stationarity
abs(polyroot(c(1, -0.7, -0.3)))
fit.test <- arima(log.price, order=c(2,0,1))
fit.test
fit.test <- arima(log.price, order=c(2,0,1))
fit.test
abs(polyroot(c(1, -0.7, -0.25)))
library(fpp)
fit.final <- auto.arima(log.price, max.p=10, max.q=10,
stationary=TRUE, seasonal=FALSE, ic="aic",
stepwise=FALSE)
fit.final
checkresiduals(fit.final)
library(fGarch)
X.garch <- garchFit(~garch(1,1), data=X, include.mean=FALSE, trace = FALSE)
library(MASS)
data(SP500)  ###returns
par(mfrow=c(2,1))
plot(SP500, type = 'l')
acf(SP500)
par(mfrow=c(1,1))
mean.SP=mean(SP500)
acf((SP500-mean.SP)^2)  ###ACF of square returns
#####Simulation and fitting of a GARCH(1,1) model
set.seed(62727)
alpha0 <- 1
alpha1 <- 0.2
beta1  <- 0.3
W    <- rnorm(1000)
X    <- rep(0, 1000)
sigma.2 <- rep(NA, 1000)
sigma.2[1] <- 0.5
for (i in 2:1000) {
sigma.2[i] <- alpha0 + alpha1 * (X[i - 1]^2) + beta1 *(sigma[i -1]^2)
X[i]     <- W[i]*sqrt(sigma.2[i])
}
acf(X^2)
#####Simulation and fitting of a GARCH(1,1) model
set.seed(62727)
alpha0 <- 1
alpha1 <- 0.2
beta1  <- 0.3
W    <- rnorm(1000)
X    <- rep(0, 1000)
sigma.2 <- rep(NA, 1000)
sigma.2[1] <- 0.5
for (i in 2:1000) {
sigma.2[i] <- alpha0 + alpha1 * (X[i - 1]^2) + beta1 *(sigma[i -1]^2)
X[i]     <- W[i]*sqrt(sigma.2[i])
}
#####Simulation and fitting of a GARCH(1,1) model
set.seed(62727)
alpha0 <- 1
alpha1 <- 0.2
beta1  <- 0.3
W    <- rnorm(1000)
X    <- rep(0, 1000)
sigma.2 <- rep(NA, 1000)
sigma.2[1] <- 0.5
for (i in 2:1000) {
sigma.2[i] <- alpha0 + alpha1 * (X[i - 1]^2) + beta1 *(sigma.2[i -1]^2)
X[i]     <- W[i]*sqrt(sigma.2[i])
}
acf(X)
X
sigma.2
#####Simulation and fitting of a GARCH(1,1) model
set.seed(62727)
alpha0 <- 1
alpha1 <- 0.2
beta1  <- 0.3
W    <- rnorm(1000)
X    <- rep(0, 1000)
sigma.2 <- rep(NA, 1000)
sigma.2[1] <- 0.5
for (i in 2:1000) {
sigma.2[i] <- alpha0 + alpha1 * (X[i - 1]^2) + beta1 *(sigma.2[i -1]^2)
X[i]     <- W[i]*sqrt(sigma.2[i])
}
acf(X)
#####Simulation and fitting of a GARCH(1,1) model
set.seed(62727)
alpha0 <- 1
alpha1 <- 0.2
beta1  <- 0.3
W    <- rnorm(1000)
X    <- rep(0, 1000)
sigma.2 <- rep(NA, 1000)
sigma.2[1] <- 0.5
for (i in 2:1000) {
sigma.2[i] <- alpha0 + alpha1 * (X[i - 1]^2) + beta1 *(sigma.2[i -1])
X[i]     <- W[i]*sqrt(sigma.2[i])
}
acf(X)
acf(X^2)
install.packages("fGarch")
library(fGarch)
X.garch <- garchFit(~garch(1,1), data=X, include.mean=FALSE, trace = FALSE)
summary(X.garch)
###SP500 Fitting
sp.garch <- garchFit(~garch(1,1), data=SP500, include.mean = FALSE,  trace = F)
summary(sp.garch)
sp.res <- residuals(sp.garch, standardize=TRUE)[-1]
acf(sp.res)
acf(sp.res^2)
###Douglas Fir Data
####width of a tree's year rings over a period from 1107 to 1964
library(forecast)
install.packages("artfima")
library(artfima)
X=eaglecol  ###Data
tsdisplay(X)
auto.arima(X) ##gives ARM(1,3) model
train <- window(X, start=1107, end=1900)
fit <- arima(train, order=c(1,0,3))
fc <- predict(fit, n.ahead=64)
plot(window(X, 1800, 1964), lty=3, ylab="")
lines(train, lwd=1)
lines(fc$pred, lwd=2, col="red")
lines(fc$pred+fc$se*1.96, col="red")
lines(fc$pred-fc$se*1.96, col="red")
title("Douglas Fir Data: 64-Step Prediction Based on ARMA(1,3)")
library(MASS)
data(SP500)  ###returns
par(mfrow=c(2,1))
plot(SP500, type = 'l')
acf(SP500)
par(mfrow=c(1,1))
mean.SP=mean(SP500)
acf((SP500-mean.SP)^2)  ###ACF of square returns
acf(SP500)
library(fGarch)
###SP500 Fitting
sp.garch <- garchFit(~garch(1,1), data=SP500, include.mean = FALSE,  trace = F)
summary(sp.garch)
sp.res <- residuals(sp.garch, standardize=TRUE)[-1]
acf(sp.res)
acf(sp.res^2)
help("garchFit")
###SP500 Fitting
sp.garch <- garchFit(~garch(1,1), data=SP500, include.mean = FALSE,  trace = F)
summary(sp.garch)
sp.res <- residuals(sp.garch, standardize=TRUE)[-1]
acf(sp.res)
acf(sp.res^2)
###QMLE
help("garchFit")
sp.garch.QMLE <- garchFit(~garch(1,1), data=SP500, include.mean = FALSE,  trace = F,
cond.dist = "QMLE")
summary(sp.garch.QMLE)
linearpoisson.ts <- function(d,a1, b1,size)
{
y            <-  rep(NA, size)
mu           <-  rep(NA, size)
theta        <-  rep(NA, size)
mu[1]        <-  1 ####initial value
y[1]         <-  rpois(1, mu[1])
for (t in 2:size){
mu[t]     <- d+a1*mu[t-1]+b1*y[t-1]
y[t]      <- rpois(1, mu[t])
}
return(cbind(y,mu))
}
par(mfcol=c(2,2))
y1=linearpoisson.ts(1,0,0.6,500)[301:500,1]  ####a simple INARCH model
ts.plot(y1, xlab="Time", ylab="Response")
acf(y1, main="", lag.max=30, ci=0)
y2=linearpoisson.ts(1,0.3,0.6,500)[301:500,1]  ###A simple INGARCH model
ts.plot(y2, xlab="Time", ylab="Response")
acf(y2, main="", lag.max=30, ci=0)
loglinearpoisson1.ts <- function(d, a1,b1,size)
{
y            <-  rep(NA, size)
mu           <-  rep(NA, size)
theta        <-  rep(NA, size)
theta[1]     <-  0
mu[1]        <-  1 ####initial value
y[1]         <-  rpois(1, mu[1])
for (t in 2:size){
theta[t]  <- d+a1*theta[t-1]+b1*log(y[t-1]+1)
mu[t]     <- exp(theta[t])
y[t]      <- rpois(1, mu[t])
}
return(cbind(y,mu))
}
par(mfcol=c(2,2))
y1log=loglinearpoisson1.ts(0.1,0,0.6,500)[301:500,1]  ####a simple INARCH model
ts.plot(y1log, xlab="Time", ylab="Response")
acf(y1log, main="", lag.max=30, ci=0)
y2log=loglinearpoisson1.ts(0.1,0.3,0.6,500)[301:500,1]  ###A simple INGARCH model
ts.plot(y2log, xlab="Time", ylab="Response")
acf(y2log, main="", lag.max=30,ci=0)
c3.ts <- c(6, 7, 8 ,9 ,6, 8, 5, 3, 7, 11, 8,4, 2, 3, 4, 5, 7, 8, 12, 11,
12, 6, 2, 2, 3, 3, 5, 6, 13, 12, 21, 9, 11, 11, 10, 8, 5, 4, 4, 4,
2, 9, 8, 5, 10, 12, 11, 9, 4, 5, 5, 10, 14, 7, 11, 12, 7, 8, 14, 6,
4, 3, 4, 4, 7, 6, 9, 8, 2, 4, 3, 1, 3, 1, 4, 3, 5, 3, 8, 11,
7, 9, 5, 3, 6, 4, 5, 6, 7, 7, 3, 5, 5, 4, 4, 2, 3, 6, 3, 1,
3, 6, 5, 9, 9, 5, 6, 4, 6, 2, 4, 1, 6, 5, 3, 2, 2, 2, 9, 5)
round(mean(c3.ts),3)
round(var(c3.ts),3)
####Plot the Data
########################################
par(mfcol=c(3,1))
ts.plot(c3.ts, xlab="Time", ylab="Claims", main="(a)")
acf(c3.ts, main="(b)")
acf(c3.ts, type="partial", main="(c)")
library(tscount)
set.seed(12345678)
###AR(1) model
fit1Poisson=tsglm(c3.ts, model=list(past_obs=1), init.drop=T)
summary(fit1Poisson)
predict(fit1Poisson)
pit(fit1Poisson)
###AR(2) model
fit2Poisson=tsglm(c3.ts, model=list(past_obs=1:2), init.drop=T)
summary(fit2Poisson)
predict(fit2Poisson)
pit(fit2Poisson)
####Log-linear AR(1)
fit1Poissonloglin=tsglm(c3.ts, model=list(past_obs=1), link="log", init.drop=T)
summary(fit1Poissonloglin)
predict(fit1Poissonloglin)
pit(fit1Poissonloglin)
###Log-linear AR(2)
fit2Poissonloglin=tsglm(c3.ts, model=list(past_obs=1:2), link="log", init.drop=T)
summary(fit2Poissonloglin)
predict(fit2Poissonloglin)
pit(fit2Poissonloglin)
####Plot the Data
########################################
tsdisplay(c3.ts)
library(forecast)
####Plot the Data
########################################
tsdisplay(c3.ts)
library(tscount)
set.seed(12345678)
###AR(1) model
fit1Poisson=tsglm(c3.ts, model=list(past_obs=1), init.drop=T)
summary(fit1Poisson)
predict(fit1Poisson)
pit(fit1Poisson)
###AR(2) model
fit2Poisson=tsglm(c3.ts, model=list(past_obs=1:2), init.drop=T)
summary(fit2Poisson)
predict(fit2Poisson)
pit(fit2Poisson)
####Log-linear AR(1)
fit1Poissonloglin=tsglm(c3.ts, model=list(past_obs=1), link="log", init.drop=T)
summary(fit1Poissonloglin)
predict(fit1Poissonloglin)
pit(fit1Poissonloglin)
###Log-linear AR(2)
fit2Poissonloglin=tsglm(c3.ts, model=list(past_obs=1:2), link="log", init.drop=T)
summary(fit2Poissonloglin)
predict(fit2Poissonloglin)
pit(fit2Poissonloglin)
help("tscount")
help("tscount-package")
vignette("tsglm", package="tscount")
linearpoisson.ts <- function(d,a1, b1,size)
{
y            <-  rep(NA, size)
mu           <-  rep(NA, size)
theta        <-  rep(NA, size)
mu[1]        <-  1 ####initial value
y[1]         <-  rpois(1, mu[1])
for (t in 2:size){
mu[t]     <- d+a1*mu[t-1]+b1*y[t-1]
y[t]      <- rpois(1, mu[t])
}
return(cbind(y,mu))
}
par(mfcol=c(2,2))
y1=linearpoisson.ts(1,0,0.6,500)[301:500,1]  ####a simple INARCH model
ts.plot(y1, xlab="Time", ylab="Response")
acf(y1, main="", lag.max=30, ci=0)
y2=linearpoisson.ts(1,0.3,0.6,500)[301:500,1]  ###A simple INGARCH model
ts.plot(y2, xlab="Time", ylab="Response")
acf(y2, main="", lag.max=30, ci=0)
loglinearpoisson1.ts <- function(d, a1,b1,size)
{
y            <-  rep(NA, size)
mu           <-  rep(NA, size)
theta        <-  rep(NA, size)
theta[1]     <-  0
mu[1]        <-  1 ####initial value
y[1]         <-  rpois(1, mu[1])
for (t in 2:size){
theta[t]  <- d+a1*theta[t-1]+b1*log(y[t-1]+1)
mu[t]     <- exp(theta[t])
y[t]      <- rpois(1, mu[t])
}
return(cbind(y,mu))
}
par(mfcol=c(2,2))
y1log=loglinearpoisson1.ts(0.1,0,0.6,500)[301:500,1]  ####a simple INARCH model
ts.plot(y1log, xlab="Time", ylab="Response")
acf(y1log, main="", lag.max=30, ci=0)
y2log=loglinearpoisson1.ts(0.1,0.3,0.6,500)[301:500,1]  ###A simple INGARCH model
ts.plot(y2log, xlab="Time", ylab="Response")
acf(y2log, main="", lag.max=30,ci=0)
c3.ts <- c(6, 7, 8 ,9 ,6, 8, 5, 3, 7, 11, 8,4, 2, 3, 4, 5, 7, 8, 12, 11,
12, 6, 2, 2, 3, 3, 5, 6, 13, 12, 21, 9, 11, 11, 10, 8, 5, 4, 4, 4,
2, 9, 8, 5, 10, 12, 11, 9, 4, 5, 5, 10, 14, 7, 11, 12, 7, 8, 14, 6,
4, 3, 4, 4, 7, 6, 9, 8, 2, 4, 3, 1, 3, 1, 4, 3, 5, 3, 8, 11,
7, 9, 5, 3, 6, 4, 5, 6, 7, 7, 3, 5, 5, 4, 4, 2, 3, 6, 3, 1,
3, 6, 5, 9, 9, 5, 6, 4, 6, 2, 4, 1, 6, 5, 3, 2, 2, 2, 9, 5)
round(mean(c3.ts),3)
round(var(c3.ts),3)
library(forecast)
####Plot the Data
########################################
tsdisplay(c3.ts)
library(tscount)
set.seed(12345678)
###AR(1) model
fit1Poisson=tsglm(c3.ts, model=list(past_obs=1), init.drop=T)
summary(fit1Poisson)
predict(fit1Poisson)
pit(fit1Poisson)
###AR(2) model
fit2Poisson=tsglm(c3.ts, model=list(past_obs=1:2), init.drop=T)
summary(fit2Poisson)
predict(fit2Poisson)
pit(fit2Poisson)
####Log-linear AR(1)
fit1Poissonloglin=tsglm(c3.ts, model=list(past_obs=1), link="log", init.drop=T)
summary(fit1Poissonloglin)
predict(fit1Poissonloglin)
pit(fit1Poissonloglin)
###Log-linear AR(2)
fit2Poissonloglin=tsglm(c3.ts, model=list(past_obs=1:2), link="log", init.drop=T)
summary(fit2Poissonloglin)
predict(fit2Poissonloglin)
pit(fit2Poissonloglin)
vignette("tsglm", package="tscount")
###Quarterly earnings of J & J
library(astsa)
tsplot(jj, col=4, type="o", ylab="Quarterly Earnings per Share", main="J & J Data")
trend.est.jj <- filter(jj, filter=c(1,1,1)/3)
lines(trend.est.jj, col=2)
trend.est.jj2 <- filter(jj, filter=c(1,1,1,1,1)/5)
lines(trend.est.jj2, col=3)
#####################
data("AirPassengers")
ts.plot(AirPassengers, main="Air Passenger Data", ylab="Bookings", col=2)
coef.filter <- c(0.5, rep(1,11), 0.5)/12
trend.est <- filter(AirPassengers, filter=coef.filter, sides=2)
lines(trend.est, col=3)
###Estimating Seasonality
trend.adj <- AirPassengers-trend.est
month     <- factor(rep(1:12,12))
seasn.est <- tapply(trend.adj, month, mean, na.rm=TRUE)
plot(seasn.est, type="h", xlab="Month")
title("Seasonal Effects for Air Passenger Data")
abline(h=0, col="blue")
####Estimating residual process
rmain.est <- AirPassengers-trend.est-rep(seasn.est,12)
ts.plot(rmain.est, main="Estimated Stochastic Residual Term", col=4 )
###R function decompose
AirPassengers.decomp <- decompose(AirPassengers)
plot(AirPassengers.decomp)
###STL Procedure
install.packages("fpp")
library(fpp)
data("elecequip")
###decomposition using seasonality that does not depend on time
ee.stl <- stl(elecequip, s.window="periodic")
plot(ee.stl, main="STL-Decomposition of Electrical Equipment Data")
##control of amount of smoothing in the trend
ee.stl$win[2]
###function to extract the decomposition parts
plot(elecequip, main="Electrical Equipment Data")
lines(trendcycle(ee.stl), col="red", lwd=2)
lines(seasadj(ee.stl), col="blue", lwd=2)
legend("topleft", c("Trend", "Seasadj"), fill  =c("red", "blue"))
AirPassengers.stl <- stl(AirPassengers, s.window="periodic")
plot(AirPassengers.stl, main="STL-AirPassengers")
####read data
Maine.unemp <- read.csv("Maine.dat", sep="", header = T)
unemp <- Maine.unemp$unemp
setwd("C:/Work/Classes/Classes at UCY/DSC534TS/Myscripts/MaineData")
####read data
Maine.unemp <- read.csv("Maine.dat", sep="", header = T)
unemp <- Maine.unemp$unemp
####simple plot
ts.plot(unemp, ylab="(%)", main="Unemployment in Maine")
####another view
plot(unemp, type="o", pch=20, ylab="(%)", main="Unemployment in Maine")
###Horizontal line plot
plot(unemp, type="h", ylab="(%)", main="Unemployment in Maine")
###GAM model
library(mgcv)
tnum <- as.numeric(time(unemp))
mm <- rep(c("Jan", "Feb", "Mar", "Apr", "May", "Jun",
"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"))
mm <- factor(rep(mm,11),levels=mm)[1:128]
fit <- gam(log(unemp) ~ s(tnum) + mm)
###Plot of data and predictions
plot(log(unemp), ylab="(%)", main="Logged Unemployment in Maine")
lines(tnum, fitted(fit), col="red")
###decomposition for trend and seasonal effect
plot(fit, shade=TRUE, xlab="", ylab="Time", main="Trend")
seas.eff <- c(0,coef(fit)[2:12])-mean(c(0,coef(fit)[2:12]))
plot(1:12, seas.eff, xlab="Month", ylab="", type="h", main="Seasonal Effect")
points(1:12, seas.eff, pch=20)
abline(h=0, col="grey")
###Residual process
plot(resid(fit), type="o", pch=20)
####Read data and make a log-transformation
library(forecast)
library(fpp)
Maine.unemp <- read.csv("Maine.dat", sep="", header = T)
tsd <- ts(Maine.unemp$unemploy, start = c(1996, 1), freq = 12)
fit <- stl(log(tsd), s.window="periodic")
plot(fit)
## Trend Forecast by Linear Extrapolation
length(log(tsd))
plot(fit$time.series[,2], xlim=c(1996, 2008+9/12))
rect(2004+8/12, 1 , 2006+7/12, 2, col="grey93", border=NA)
rect(2006+7/12, 1, 2008+6/12, 2, col="grey83", border=NA)
title("Trend Forecast by Linear Extrapolation")
xx <- time(fit$time.series[,2])[105:128]
yy <- fit$time.series[105:128,2]
fit.regr <- lm(yy~xx)
summary(fit.regr)
t.fore <- 1.494 + (0:23)/12 * coef(fit.regr)[2]
lines(xx, fitted(fit.regr), col="blue")
lines(xx[1]+(23:46)/12, t.fore, col="red")
lines(fit$time.series[,2])
box()
## Seasonal Forecast Using Last Values
season <- fit$time.series[,1]
l2y <- window(season,start=c(2004,9),end=c(2006,8))
s.fore <- ts(l2y, start=c(2006,9), end=c(2008,8), freq=12)
###Error  forecast
rmndr <- fit$time.series[,3]
tsdisplay(rmndr)
fit.rmndr <- arima(rmndr, order=c(4,0,0), include.mean=F)
r.fore <- predict(fit.rmndr, n.ahead=24)$pred
## Adding the 3 Components
fore <- t.fore + s.fore + r.fore
## Displaying the Output
plot(log(tsd), xlim=c(1996, 2008.75), ylab="log(%)")
rect(2006+8/12, 0, 2008+9/12, 2, col="grey90", border=NA)
lines(fore, col="red")
box()
